<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Aurora Odyssey • Harmonic Field</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet" />
    <style>
        :root {
            --bg: radial-gradient(circle at 15% 20%, rgba(110, 245, 255, 0.4), transparent 55%),
                   radial-gradient(circle at 75% 30%, rgba(151, 102, 255, 0.3), transparent 60%),
                   linear-gradient(180deg, #010409 0%, #040c24 45%, #010409 100%);
            --panel: rgba(8, 12, 28, 0.8);
            --border: rgba(255, 255, 255, 0.12);
            --text: rgba(255, 255, 255, 0.92);
            --muted: rgba(255, 255, 255, 0.68);
            --accent: #6ef5ff;
            --accent-strong: #ffe483;
            --shadow: 0 25px 60px rgba(5, 10, 30, 0.35);
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: "Space Grotesk", system-ui, sans-serif;
            color: var(--text);
            background: var(--bg);
            display: grid;
            grid-template-rows: auto 1fr auto;
        }

        header,
        footer {
            padding: 2rem clamp(1.5rem, 4vw, 3.5rem);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1.5rem;
        }

        header a {
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 0.22em;
            font-size: 0.75rem;
            color: var(--text);
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
        }

        header svg {
            width: 1.1rem;
            height: 1.1rem;
        }

        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: clamp(2rem, 5vw, 3.5rem);
            padding: 0 clamp(1.5rem, 4vw, 3.5rem) clamp(2.5rem, 6vw, 4rem);
        }

        .field {
            position: relative;
            border-radius: 32px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: rgba(3, 6, 18, 0.8);
            box-shadow: var(--shadow);
            min-height: min(70vh, 600px);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .panel {
            border-radius: 28px;
            padding: clamp(1.5rem, 4vw, 2.5rem);
            background: var(--panel);
            border: 1px solid var(--border);
            backdrop-filter: blur(18px);
            box-shadow: var(--shadow);
            display: grid;
            gap: 1.6rem;
            align-content: start;
        }

        h1 {
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            font-size: clamp(1.8rem, 3.2vw, 2.6rem);
        }

        p {
            margin: 0;
            color: var(--muted);
            line-height: 1.8;
        }

        .control-grid {
            display: grid;
            gap: 1.2rem;
        }

        label {
            display: grid;
            gap: 0.45rem;
            font-size: 0.85rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent);
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        button {
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 0.65rem 1.4rem;
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            letter-spacing: 0.18em;
            text-transform: uppercase;
            font-size: 0.75rem;
            cursor: pointer;
            transition: transform 0.3s ease, border-color 0.3s ease;
        }

        button:hover,
        button:focus-visible {
            border-color: var(--accent-strong);
            transform: translateY(-2px);
        }

        footer {
            color: var(--muted);
            text-align: center;
            font-size: 0.8rem;
            letter-spacing: 0.16em;
            text-transform: uppercase;
        }

        .readout {
            font-family: "IBM Plex Mono", monospace;
            font-size: 0.8rem;
            letter-spacing: 0.14em;
            color: var(--accent-strong);
        }

        @media (max-width: 820px) {
            header {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <header>
        <a href="index.html">
            <svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6">
                <path d="M19 12H5m6 6l-6-6 6-6" />
            </svg>
            Mission Control
        </a>
        <div class="readout" id="status">Amplitude 1.00 • Frequency 3.00</div>
    </header>

    <main>
        <div class="field">
            <canvas id="field" role="img" aria-label="Interactive harmonic field"></canvas>
        </div>
        <aside class="panel">
            <div>
                <h1>Harmonic field</h1>
                <p>
                    This chamber visualises coupled oscillators using layered Lissajous curves. Pull particles with your cursor
                    or tap the screen to spawn attractors. Controls let you sculpt amplitude, frequency, and drag behaviour.
                </p>
            </div>
            <div class="control-grid">
                <label>
                    Amplitude
                    <input id="amplitude" type="range" min="0.2" max="2.5" step="0.1" value="1" />
                </label>
                <label>
                    Frequency
                    <input id="frequency" type="range" min="1" max="12" step="0.1" value="3" />
                </label>
                <label>
                    Drag
                    <input id="drag" type="range" min="0.85" max="0.995" step="0.005" value="0.94" />
                </label>
            </div>
            <div class="button-row">
                <button type="button" id="reset">Reset Swarm</button>
                <button type="button" id="freeze">Freeze Motion</button>
                <button type="button" id="burst">Pulse Burst</button>
            </div>
            <p>
                Keyboard controls: press <kbd>Space</kbd> to toggle motion, <kbd>R</kbd> to reset, and <kbd>B</kbd> to burst.
                Reduced-motion visitors start paused by default.
            </p>
        </aside>
    </main>

    <footer>Coupled oscillators rendered live • Aurora Odyssey Portals</footer>

    <script>
        const canvas = document.getElementById("field");
        const ctx = canvas.getContext("2d");
        const amplitudeInput = document.getElementById("amplitude");
        const frequencyInput = document.getElementById("frequency");
        const dragInput = document.getElementById("drag");
        const status = document.getElementById("status");
        const resetButton = document.getElementById("reset");
        const freezeButton = document.getElementById("freeze");
        const burstButton = document.getElementById("burst");
        const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        let width, height, center;
        let animationFrame;
        let running = !prefersReducedMotion;
        let time = 0;
        let lastTimestamp = 0;
        const pointer = { x: 0, y: 0, active: false };

        const nodes = Array.from({ length: 240 }, () => ({
            angle: Math.random() * Math.PI * 2,
            radius: Math.random(),
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
        }));

        const settings = {
            amplitude: parseFloat(amplitudeInput.value),
            frequency: parseFloat(frequencyInput.value),
            drag: parseFloat(dragInput.value),
        };

        function resize() {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            center = { x: width / 2, y: height / 2 };
        }

        function updateStatus() {
            status.textContent = `Amplitude ${settings.amplitude.toFixed(2)} • Frequency ${settings.frequency.toFixed(2)}`;
        }

        function advance(timestamp) {
            if (!lastTimestamp) {
                lastTimestamp = timestamp;
            }
            const delta = (timestamp - lastTimestamp) * 0.0012;
            lastTimestamp = timestamp;
            time += delta;
        }

        function integrateNodes() {
            nodes.forEach((node, index) => {
                const base = settings.amplitude * (0.6 + node.radius * 0.6);
                const freq = settings.frequency * (0.7 + index / nodes.length);
                const xTarget = Math.sin(time * freq + node.angle * 3) * base * width * 0.25;
                const yTarget = Math.cos(time * freq * 0.7 + node.angle * 2) * base * height * 0.22;

                node.vx += (xTarget - node.x) * 0.02;
                node.vy += (yTarget - node.y) * 0.02;

                if (pointer.active) {
                    const dx = pointer.x - (node.x + center.x);
                    const dy = pointer.y - (node.y + center.y);
                    const dist = Math.hypot(dx, dy) + 0.001;
                    const force = Math.min(120 / dist, 3);
                    node.vx += dx / dist * force * 0.04;
                    node.vy += dy / dist * 0.04;
                }

                node.vx *= settings.drag;
                node.vy *= settings.drag;

                node.x += node.vx;
                node.y += node.vy;
            });
        }

        function drawField(update = true) {
            ctx.fillStyle = `rgba(2, 6, 20, ${update ? 0.36 : 1})`;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.translate(center.x, center.y);

            ctx.lineWidth = 1.4;
            ctx.strokeStyle = `hsla(${(time * 60) % 360}, 85%, 65%, 0.65)`;
            ctx.beginPath();
            nodes.forEach((node, index) => {
                const next = nodes[(index + 1) % nodes.length];
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(next.x, next.y);
            });
            ctx.stroke();

            ctx.globalCompositeOperation = "lighter";
            nodes.forEach((node, index) => {
                const hue = (time * 80 + index) % 360;
                ctx.fillStyle = `hsla(${hue}, 90%, 70%, 0.7)`;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 1.8 + Math.sin(time + index) * 0.6, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalCompositeOperation = "source-over";

            ctx.restore();
        }

        function renderFrame(timestamp, update = true) {
            if (update) {
                advance(timestamp);
                integrateNodes();
            }
            drawField(update);
        }

        function step(timestamp) {
            if (!running) return;
            renderFrame(timestamp, true);
            animationFrame = requestAnimationFrame(step);
        }

        function start() {
            if (!running) {
                running = true;
                lastTimestamp = performance.now();
                animationFrame = requestAnimationFrame(step);
                freezeButton.textContent = "Freeze Motion";
            }
        }

        function stop() {
            running = false;
            cancelAnimationFrame(animationFrame);
            freezeButton.textContent = "Resume Motion";
            renderFrame(lastTimestamp || performance.now(), false);
        }

        function toggle() {
            running ? stop() : start();
        }

        function reset() {
            nodes.forEach((node) => {
                node.x = 0;
                node.y = 0;
                node.vx = 0;
                node.vy = 0;
            });
            time = 0;
            lastTimestamp = 0;
            renderFrame(performance.now(), running);
        }

        function burst() {
            nodes.forEach((node) => {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 12 + 4;
                node.vx += Math.cos(angle) * speed;
                node.vy += Math.sin(angle) * speed;
            });
            renderFrame(performance.now(), true);
            if (!running) {
                renderFrame(performance.now(), false);
            }
        }

        amplitudeInput.addEventListener("input", () => {
            settings.amplitude = parseFloat(amplitudeInput.value);
            updateStatus();
        });

        frequencyInput.addEventListener("input", () => {
            settings.frequency = parseFloat(frequencyInput.value);
            updateStatus();
        });

        dragInput.addEventListener("input", () => {
            settings.drag = parseFloat(dragInput.value);
        });

        resetButton.addEventListener("click", reset);
        freezeButton.addEventListener("click", toggle);
        burstButton.addEventListener("click", burst);

        window.addEventListener("keydown", (event) => {
            if (event.code === "Space") {
                event.preventDefault();
                toggle();
            }
            if (event.key === "r" || event.key === "R") {
                reset();
            }
            if (event.key === "b" || event.key === "B") {
                burst();
            }
        });

        function setPointerPosition(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            pointer.x = clientX - rect.left;
            pointer.y = clientY - rect.top;
        }

        canvas.addEventListener("pointerdown", (event) => {
            pointer.active = true;
            setPointerPosition(event.clientX, event.clientY);
        });

        canvas.addEventListener("pointermove", (event) => {
            if (!pointer.active) return;
            setPointerPosition(event.clientX, event.clientY);
        });

        window.addEventListener("pointerup", () => {
            pointer.active = false;
        });

        canvas.addEventListener("touchmove", (event) => {
            if (event.touches[0]) {
                pointer.active = true;
                setPointerPosition(event.touches[0].clientX, event.touches[0].clientY);
            }
        }, { passive: false });

        canvas.addEventListener("touchend", () => {
            pointer.active = false;
        });

        window.addEventListener("resize", () => {
            resize();
            renderFrame(performance.now(), running);
        });

        resize();
        updateStatus();
        if (running) {
            lastTimestamp = performance.now();
            animationFrame = requestAnimationFrame(step);
        } else {
            renderFrame(performance.now(), false);
        }
    </script>
</body>
</html>
